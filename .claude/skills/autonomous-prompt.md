---
name: autonomous-prompt
description: Generate autonomous implementation prompts for GitHub issues, enabling complete implementation without user intervention. Use when asked to generate prompts for issues like 'prompt for issue #XX', 'create prompt', or 'generate implementation prompt'.
---

# Autonomous Implementation Prompt Skill

Generate a world-class autonomous implementation prompt for a GitHub issue that enables complete, thorough implementation without user intervention.

## How to Use

The user will provide an issue number. You should:

1. Fetch the issue details
2. Understand the context and requirements
3. Generate a comprehensive autonomous prompt
4. Save the prompt to `prompts/`
5. Commit and push the prompt file
6. Execute the prompt to implement the issue

## Prompt Generation Process

### Phase 1: Understand the Issue

1. **Fetch issue details**
   ```bash
   gh issue view <number> --json number,title,body,labels
   ```

2. **Analyze the issue**
   - What is being requested?
   - Is this a bug fix, feature, test, or refactoring?
   - What are the success criteria?
   - Are there related issues or PRs?
   - Is there a plan document referenced?

3. **Determine scope**
   - What files will be modified?
   - What new files will be created?
   - Are there dependencies on other issues?
   - What's in scope vs out of scope?

### Phase 2: Generate the Prompt

Create a comprehensive prompt following this structure:

```markdown
<!--
AUTONOMOUS IMPLEMENTATION PROMPT
===============================
This file is an autonomous implementation prompt generated by Claude Code.

Purpose: Reference/template for autonomous feature implementation
Usage: Can be copied and adapted for similar features
Structure:
- Context section: Issue details and requirements
- Pre-Implementation: Research and planning
- Implementation: Step-by-step coding tasks
- Quality Assurance: Tests, build, formatting
- PR Creation: Final pull request

This is NOT documentation - it's a prompt that Claude Code executes.
-->

# Autonomous Implementation: [Issue Title] (Issue #XX)

I want you to implement [brief description] as specified in GitHub Issue #XX. Work completely autonomously through the entire implementation without requiring my input.

## Context

**Issue**: #XX - [Title]
**Type**: [Bug Fix / Feature / Testing / Refactoring]
**Priority**: [P0/P1/P2 from issue labels]
**Related**: [List related issues, PRs, or plan documents]

**Goal**: [What needs to be accomplished]

**Success Criteria**:
- [Criterion 1 from issue]
- [Criterion 2 from issue]
- [etc.]

## Pre-Implementation Phase

### 1. Read and Understand

**Required Reading**:
- [ ] **Read** the GitHub issue #XX completely
- [ ] **Read** [relevant files from issue description]
- [ ] **Read** `Lean Canvas.md` - Understand product vision and positioning
- [ ] **Read** `Competitive Feature List.md` - Understand feature requirements and differentiation
- [ ] **Check** for any plan documents mentioned in the issue
- [ ] **Review** @CLAUDE.md for project conventions

**Understand**:
- Current implementation and what needs to change
- Why this change is needed (the "why" behind the "what")
- Edge cases and potential issues
- Testing requirements

### 2. Verify Prerequisites

- [ ] Verify you're in the correct worktree directory
- [ ] Check that all dependencies are installed (`npm install` status)
- [ ] Confirm you understand the acceptance criteria

### 3. Create Todo List

- [ ] Create comprehensive todo list with all implementation steps
- [ ] Include quality checks (tests, types, formatting)
- [ ] Include documentation tasks
- [ ] One todo should be in_progress at any time
- [ ] Mark todos completed immediately after finishing

## Implementation Phase

### 1. Follow Implementation Steps

[Specific steps based on issue type - see templates below]

### 2. Make Incremental Commits and Push

- [ ] Write clear commit messages referencing the issue
- [ ] **Push each commit immediately** after creating it
- [ ] First push: `git push -u origin issue-XX`
- [ ] Subsequent pushes: `git push`
- [ ] Logical groupings of changes per commit

### 3. Handle Issues and Blockers

If you encounter problems:
- **Think deeply** about the project and analyze relevant files
- **Research** industry best practices
- **Make a decision** about how to proceed
- **Document** your reasoning in the code or commit message
- **Do NOT ask the user** - proceed autonomously

[Issue-type-specific implementation details here]

## Quality Assurance Phase

### 1. Run Tests

```bash
npm test
```

- [ ] All tests pass
- [ ] No new test failures introduced
- [ ] Coverage is appropriate

### 2. Build Validation

```bash
npx expo export --platform ios
```

- [ ] Build succeeds with no errors
- [ ] No new TypeScript errors
- [ ] No new warnings introduced

### 3. Code Quality

- [ ] Verify no `any` types introduced
- [ ] Remove commented-out code
- [ ] Verify all imports are correct

### 4. Project Conventions

From @CLAUDE.md:
- [ ] Using npm (not pnpm or yarn)
- [ ] Dark mode support if UI changes
- [ ] No emojis in UI - use icons instead
- [ ] Proper accessibility labels

## Documentation Phase

### 1. Update Issue

- [ ] Add implementation notes as a comment
- [ ] Document any deviations from requirements
- [ ] Note any follow-up work needed

### 2. Update Plan Document (if applicable)

- [ ] Move plan to `plans/completed/` if implementation is complete
- [ ] Add implementation notes section
- [ ] Document decisions made

## Pull Request Phase

### 1. Submit PR Using submit-pr Skill

**IMPORTANT**: Every autonomous implementation MUST finalize the PR using the **submit-pr skill**. This skill handles everything: PR creation, code review, implementing ALL feedback, and final verification.

```
Use the submit-pr skill to finalize the PR for this implementation.
```

**The submit-pr skill orchestrates the complete quality pipeline:**

1. **Create PR** (via create-pr skill):
   - Detect the existing draft PR on this branch
   - Update the PR title and description with implementation details
   - Convert the draft PR to ready for review
   - Run quality validation (build, tests)

2. **Review Loop** (via review-loop skill):
   - **First Code Review**: Comprehensive analysis for correctness, quality, testing, performance, security
   - **Implement ALL Feedback**: Every suggestion is implemented (not just critical issues)
   - **Second Code Review**: Verify all feedback was addressed

### 2. Verify PR

After the submit-pr skill completes:
- [ ] PR is no longer a draft
- [ ] PR description is complete and comprehensive
- [ ] Links to issue with "Closes #XX" format
- [ ] All commits are pushed to the branch
- [ ] `ready-for-review` label is present
- [ ] First code review completed
- [ ] ALL review feedback implemented
- [ ] Second code review verified changes
- [ ] PR URL is returned to user

## Communication

**Progress Updates**:
- Provide updates when starting each major phase
- Share when completing significant milestones
- Give status updates every 30-60 minutes of work

**Incremental Commits**:
- Commit and push regularly throughout implementation
- Each logical unit of work should be a separate commit
- Push after every commit so progress is visible in the draft PR
- Don't batch up large changes - small commits are better

**Final Summary**:
When complete, report:
- What was implemented
- Any deviations from the issue
- How to test the changes
- **PR URL** (this is required)
- Summary of code review findings and implemented feedback
- Any follow-up work needed

**Critical Reminder**: Do NOT consider the implementation complete until:
1. All code is committed and pushed
2. The **submit-pr skill** has been used
3. PR is converted from draft to ready-for-review
4. PR has "Closes #XX" in the description
5. **Two code reviews completed** with ALL feedback implemented
6. PR URL is provided to the user

---

**Ready to begin autonomous implementation. Proceed without waiting for user confirmation.**
```

### Issue Type Templates

#### For Bug Fix Issues

```markdown
## Bug Fix Implementation Steps

1. **Reproduce the Bug**
   - [ ] Understand the bug from issue description
   - [ ] Locate the code causing the bug
   - [ ] Understand why the bug occurs

2. **Fix the Root Cause**
   - [ ] Implement fix that addresses root cause (not just symptoms)
   - [ ] Ensure fix doesn't introduce new issues
   - [ ] Consider if similar bugs exist elsewhere

3. **Add Regression Test**
   - [ ] Write test that would have caught this bug
   - [ ] Verify test fails with old code
   - [ ] Verify test passes with fix

4. **Update Related Code**
   - [ ] Check for similar patterns that might have same bug
   - [ ] Update documentation if bug was due to misunderstanding
```

#### For Feature Issues

```markdown
## Feature Implementation Steps

### 1. Review Plan Document
   - [ ] Read plan document thoroughly if referenced
   - [ ] Understand architecture and approach
   - [ ] Note all acceptance criteria

### 2. Implement Feature
   - [ ] Follow plan implementation steps
   - [ ] Create necessary files
   - [ ] Implement core functionality
   - [ ] Add error handling
   - [ ] Support dark mode for UI changes

### 3. Add Tests
   - [ ] Unit tests for business logic
   - [ ] Integration tests if needed

### 4. Documentation
   - [ ] Update relevant documentation
   - [ ] Add code comments for complex logic
   - [ ] Update plan status
```

#### For Testing Issues

```markdown
## Testing Implementation Steps

1. **Understand What to Test**
   - [ ] Read the module/function being tested
   - [ ] Identify all code paths and edge cases
   - [ ] Review plan document for test requirements

2. **Write Tests**
   - [ ] Use descriptive test names
   - [ ] Cover happy path, edge cases, error cases
   - [ ] Aim for target coverage percentage

3. **Verify Tests**
   - [ ] All tests pass
   - [ ] Tests actually test the right things
   - [ ] No false positives
   - [ ] Tests will catch regressions
```

### Phase 3: Save Prompt, Create Draft PR

1. **Determine filename**
   - Use pattern: `implement-issue-XX.md` or `fix-issue-XX.md`
   - Be descriptive: `implement-issue-32-student-chat.md`

2. **Fast-forward to latest main**
   ```bash
   git fetch origin main
   git merge --ff-only origin/main
   ```

3. **Save to prompts directory**
   ```bash
   cat > prompts/implement-issue-XX-description.md <<'EOF'
   [Generated prompt content]
   EOF
   ```

4. **Commit and push**
   ```bash
   git add prompts/implement-issue-XX-description.md
   git commit -m "Add autonomous implementation prompt for issue #XX"
   git push
   ```

5. **Create draft PR with in-progress label**

   ```bash
   ISSUE_NUM=XX
   ISSUE_TITLE=$(gh issue view $ISSUE_NUM --json title --jq '.title')

   # Use the Blade helper script so the PR is authored as the Blades account
   ./scripts/blade-create-pr.sh

   # Optionally convert to draft and add in-progress label if needed
   PR_NUMBER=$(gh pr view --json number --jq '.number')
   gh pr edit "$PR_NUMBER" --add-label "in-progress" --draft
   ```

### Phase 4: Execute the Prompt

1. **Read the saved prompt**
   ```bash
   Read prompts/implement-issue-XX-description.md
   ```

2. **Use as your instructions**
   - Follow the prompt exactly as if the user gave it to you
   - Work autonomously through all phases
   - Provide progress updates as specified
   - Complete the implementation

### Phase 5: Document Implementation Success

After successfully implementing and creating a PR:

1. **Add implementation metadata**
   ```markdown
   <!-- Successfully implemented in PR #XX - https://github.com/.../pull/XX -->
   <!-- Implementation completed: YYYY-MM-DD -->

   # Autonomous Implementation: [Title]
   ```

2. **Commit the update**
   ```bash
   git add prompts/implement-issue-XX-description.md
   git commit -m "Document successful implementation of issue #XX"
   git push
   ```

## Prompt Quality Guidelines

### Be Comprehensive
- Include ALL necessary context from the issue
- Don't assume prior knowledge
- Specify exact files to read
- List all acceptance criteria

### Be Specific
- Name exact files and functions
- Specify test commands
- Provide code examples where helpful
- Define success criteria clearly

### Be Structured
- Use clear phases and checklists
- One task per checkbox
- Logical ordering of steps
- Clear dependencies between steps

### Be Autonomous
- Anticipate questions and answer them in the prompt
- Provide decision-making frameworks
- Specify when to document decisions
- Minimize need for clarification

### Reference Standards
- Link to @CLAUDE.md for conventions

## Example Workflow

User: "issue 32"

You should:
1. Fetch issue #32 details
2. Analyze: It's a feature for student chat interface
3. Generate comprehensive prompt with feature template
4. Save to `prompts/implement-issue-32-student-chat.md`
5. Commit and push
6. Read the prompt file
7. Execute the implementation following the prompt exactly

## Common Pitfalls to Avoid

- **Too Vague**: "Fix the bug" → "Fix token counting by using server-side calculation"
- **Missing Context**: Assumes knowledge → Specifies all files to read
- **No Structure**: Wall of text → Phased approach with checklists
- **No Quality Checks**: Just implementation → QA phase with tests, build
- **No Documentation**: Just code → Update issues, plans, create PR

## Success Criteria

A good autonomous prompt should enable implementation where:
- No user questions are needed
- All acceptance criteria are met
- Code is high quality and tested
- Documentation is updated
- Draft PR created early
- Regular commits pushed throughout
- **submit-pr skill used to finalize PR**
- **Code review loop completed**
- All in-scope review feedback addressed
- PR is ready for review with "Closes #XX"
